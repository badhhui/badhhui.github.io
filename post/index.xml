<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Hhui&#39;s blog</title>
    <link>https://blog.hhui.me/post/</link>
    <description>Recent content in Posts on Hhui&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 16 Sep 2023 15:44:03 +0800</lastBuildDate><atom:link href="https://blog.hhui.me/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>MIT s6.081 lab2</title>
      <link>https://blog.hhui.me/post/mit_s6.081_lab2/</link>
      <pubDate>Sat, 16 Sep 2023 15:44:03 +0800</pubDate>
      
      <guid>https://blog.hhui.me/post/mit_s6.081_lab2/</guid>
      <description>Lec03 OS organization and System Calls 实现强隔离性需要硬件支持：user/kernle mode、虚拟内存 ECALL指令接收一个数字参数，执行ECALL指令，传入一个数字，这里的数字参数代表了应用程序想要调用的System Call。就能将程序执行的控制权转移到内核 使用ECALL指令将控制权从应用程序转到操作系统后，内核负责实现具体的功能并检查参数以确保不会被一些坏的参数所欺骗，例如访问不属于应用程序的内存地址 宏内核：所有操作系统服务运行在kernel mode中；优点：操作系统的子模块现在都位于同一个程序中，紧密的集成在一起，这样的集成可以提供很好的性能；缺点：运行在内核中的代码更多，更容易出现BUG。 微内核：kernel mode中运行尽可能少的代码，微内核的目的在于将大部分的操作系统运行在内核之外，比如文件系统可能就是个常规的用户空间程序。优点：内核中的代码的数量较小，更少的代码意味着更少的Bug；缺点：假设我们需要让Shell能与文件系统交互，比如Shell调用了exec，通常来说，Shell会通过内核中的IPC系统发送一条消息，内核会查看这条消息并发现这是给文件系统的消息，之后内核会把消息发送给文件系统。文件系统会完成它的工作之后会向IPC系统发送回一条消息说，这是你的exec系统调用的结果，之后IPC系统再将这条消息发送给Shell。对于任何文件系统的交互，都需要分别完成2次用户空间&amp;lt;&amp;mdash;-&amp;gt;内核空间的跳转。 RISC-V结构图 在QEMU的主循环中，只在做一件事情： 读取4字节或者8字节的RISC-V指令 解析RISC-V指令，并找出对应的操作码（op code） 在软件中执行相应的指令 对于每个CPU核，QEMU都会运行这么一个循环 Lab 2 System call tracing（moderate） // kernel/syscall.h // 添加新的系统调用编号 #define SYS_trace 22 // user/usys.S // 添加trace调用的汇编处理代码 .global trace trace: li a7, SYS_trace ecall ret // kernel/sysproc.c // 添加trace的处理函数 uint64 sys_trace(void) { int mask; argint(0, &amp;amp;mask); myproc()-&amp;gt;mask = mask; return 0; } // kernel/syscall.c void syscall(void) { int num; struct proc *p = myproc(); num = p-&amp;gt;trapframe-&amp;gt;a7; if(num &amp;gt; 0 &amp;amp;&amp;amp; num &amp;lt; NELEM(syscalls) &amp;amp;&amp;amp; syscalls[num]) { p-&amp;gt;trapframe-&amp;gt;a0 = syscalls[num](); // 若当前的syscall为trace的syscall，打印该系统调用的信息 if(p-&amp;gt;mask &amp;amp; (1 &amp;lt;&amp;lt; num)) printf(&amp;#34;%d: syscall %s -&amp;gt; %d\n&amp;#34;, p-&amp;gt;pid, syscall_name[num-1], p-&amp;gt;trapframe-&amp;gt;a0); } else { printf(&amp;#34;%d %s: unknown sys call %d\n&amp;#34;, p-&amp;gt;pid, p-&amp;gt;name, num); p-&amp;gt;trapframe-&amp;gt;a0 = -1; } } // kernel/proc.</description>
    </item>
    
    <item>
      <title>MIT s6.081 lab1</title>
      <link>https://blog.hhui.me/post/mit_s6.081_lab1/</link>
      <pubDate>Wed, 06 Sep 2023 14:36:19 +0800</pubDate>
      
      <guid>https://blog.hhui.me/post/mit_s6.081_lab1/</guid>
      <description>Lab 1 sleep (easy) #include &amp;#34;kernel/types.h&amp;#34; #include &amp;#34;kernel/stat.h&amp;#34; #include &amp;#34;user/user.h&amp;#34; int main(int argc, char *argv[]) { if(argc != 2){ fprintf(2, &amp;#34;Usage: sleep &amp;lt;seconds&amp;gt;\n&amp;#34;); exit(1); } int seconds = atoi(argv[1]); // string to int sleep(seconds); // syscall exit(0); } pingpong（easy） #include &amp;#34;kernel/types.h&amp;#34; #include &amp;#34;user/user.h&amp;#34; int main(int argc, char *argv[]) { int p1[2]; // p-&amp;gt;c int p2[2]; // c-&amp;gt;p pipe(p1); pipe(p2); char c = &amp;#39;h&amp;#39;; int pid = fork(); if (pid &amp;lt; 0) { fprintf(2, &amp;#34;fork() error!</description>
    </item>
    
    <item>
      <title>eBPF学习笔记</title>
      <link>https://blog.hhui.me/post/ebpf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Fri, 14 Apr 2023 19:37:19 +0800</pubDate>
      
      <guid>https://blog.hhui.me/post/ebpf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;p&gt;eBPF学习笔记&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>F2FS</title>
      <link>https://blog.hhui.me/post/f2fs/</link>
      <pubDate>Fri, 30 Sep 2022 15:04:21 +0800</pubDate>
      
      <guid>https://blog.hhui.me/post/f2fs/</guid>
      <description>&lt;p&gt;F2FS是一个Linux文件系统，适用于闪存设备，论文的实验结果表明F2FS要比EXT4的性能好很多。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Block大小对F2FS的影响</title>
      <link>https://blog.hhui.me/post/block%E5%A4%A7%E5%B0%8F%E5%AF%B9f2fs%E7%9A%84%E5%BD%B1%E5%93%8D/</link>
      <pubDate>Fri, 30 Sep 2022 14:52:05 +0800</pubDate>
      
      <guid>https://blog.hhui.me/post/block%E5%A4%A7%E5%B0%8F%E5%AF%B9f2fs%E7%9A%84%E5%BD%B1%E5%93%8D/</guid>
      <description>&lt;p&gt;初略计算Block及node size对F2FS元数据和文件索引所占空间的影响。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
